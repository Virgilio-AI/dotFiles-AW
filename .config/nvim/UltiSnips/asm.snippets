# Fecha: 12/November/2021 - Friday                                        #
# Autor: Virgilio Murillo Ochoa                                           #
# personal github: Virgilio-AI                                            #
# linkedin: https://www.linkedin.com/in/virgilio-murillo-ochoa-b29b59203  #
# contact: virgiliomurilloochoa1@gmail.com                                #
# #########################################################################
# ========== configurations ======


# ========== global functions =
# def create_matrix_placeholders
# ========== vim related ======
# sk -- for getting a skeleton
# info -- for getting info of the author

# ========== basic input output ======
# inset - define in port
# outset - define out port
# inp - for reading the whole port
# in - for reading a single pin
# out - for getting out a single pin
# outp - for getting out a hole port with a register

# ========== basic operations ======
# goto -- to jump to an other part of the code
# +   - to add
# -   - to substract

# ========== buttons ======
# retButton - ratard for button
# retButton_h -- retrado boton help
# traba - for retarding if the button is pressed

# ========== bcd display ======
# s-dis -- for setting the display
# m-dis -- for creating a menu for the display

# ========== comparisons ======
# if - similar to if
# goto - rjmp

# ========== asingning ======
# var - alias for a register
# = - for info on asingnign 
# def - for definition of port pin or ddr

# ========== keybaord ======
# teclado_menu - a menu template for keyboard

# ========== timers and interruptions ======
# interrupciones -- configuration for interruptions
# timers -- configurar los timers

# ******************* snippets





















# ==========================
# ========== global functions ======
# ==========================
global !p
def create_matrix_placeholders(snip):
	# Create anonymous snippet body
	anon_snippet_body = ""
	# Get start and end line number of expanded snippet
	start = snip.snippet_start[0]
	end = snip.snippet_end[0]
  # Append current line into anonymous snippet
	for i in range(start, end + 1):
		anon_snippet_body += snip.buffer[i]
		anon_snippet_body += "" if i == end else "\n"
	# Delete expanded snippet line till second to last line
	for i in range(start, end):
		del snip.buffer[start]
	# Empty last expanded snippet line while preserving the line
	snip.buffer[start] = ''
	# Expand anonymous snippet
	snip.expand_anon(anon_snippet_body)
endglobal
post_jump "snip"
global !p
def returnCommandSplitted(command):
	cmd_arr = command.split('_')
	return_command = ""
	for a in cmd_arr:
		return_command += a + " "
	return_command = return_command[0:len(return_command)-1]
	return return_command
endglobal



# ==========================
# ========== vim related ======
# ==========================
snippet sk
;******************************************************
; ${2:Titulo del proyecto}
;
; Fecha: `date +%d/%B/%Y\ -\ %A`
; Autor: Virgilio Murillo Ochoa
; github personal: Virgilio-AI
; contact: virgiliomurilloochoa1@gmail.com

; Miembros del equipo: Alfredo Castrellon
; $1

;******************************************************
.include "m16def.inc"
;******************************************************
;Registros (aquí pueden definirse)
;.def temporal=r19
;Palabras claves (aquí pueden definirse)
;.equ LCD_DAT=DDRC
;******************************************************
.org 0x0000
;Comienza el vector de interrupciones.
jmp RESET ; Reset Handler
jmp EXT_INT0 ; IRQ0 Handler
jmp EXT_INT1 ; IRQ1 Handler
jmp TIM2_COMP ; Timer2 Compare Handler
jmp TIM2_OVF ; Timer2 Overflow Handler
jmp TIM1_CAPT ; Timer1 Capture Handler
jmp TIM1_COMPA ; Timer1 CompareA Handler
jmp TIM1_COMPB ; Timer1 CompareB Handler
jmp TIM1_OVF ; Timer1 Overflow Handler
jmp TIM0_OVF ; Timer0 Overflow Handler
jmp SPI_STC ; SPI Transfer Complete Handler
jmp USART_RXC ; USART RX Complete Handler
jmp USART_UDRE ; UDR Empty Handler
jmp USART_TXC ; USART TX Complete Handler
jmp ADC_COMP ; ADC Conversion Complete Handler
jmp EE_RDY ; EEPROM Ready Handler
jmp ANA_COMP ; Analog Comparator Handler
jmp TWSI ; Two-wire Serial Interface Handler
jmp EXT_INT2 ; IRQ2 Handler
jmp TIM0_COMP ; Timer0 Compare Handler
jmp SPM_RDY ; Store Program Memory Ready Handler
; Termina el vector de interrupciones.
;******************************************************
;Aquí comenzará el programa
;******************************************************
Reset:
;Primero inicializamos el stack pointer...
ldi r16, high(RAMEND)
out SPH, r16
ldi r16, low(RAMEND)
out SPL, r16 
;******************************************************
;No olvides configurar al inicio los puertos que utilizarás
;También debes configurar si habrá o no pull ups en las entradas
;Para las salidas deberás indicar cuál es la salida inicial
;Los registros que vayas a utilizar inicializalos si es necesario
;******************************************************


; ******* setting input output ******************  inset, outset
$3

; ************** definition of variables ********* var
.def t1 = r16
ldi t1,0
.def t2 = r17
ldi t2,0
; ************** actions to do at the beggining ***

; ************* main program **********************









;******************************************************
;Aquí están las rutinas para el manejo de las interrupciones concretas
;******************************************************

EXT_INT0: ; IRQ0 Handler
reti
EXT_INT1: 
reti ; IRQ1 Handler
TIM2_COMP: 
reti ; Timer2 Compare Handler
TIM2_OVF: 
reti ; Timer2 Overflow Handler
TIM1_CAPT: 
reti ; Timer1 Capture Handler
TIM1_COMPA: 
reti ; Timer1 CompareA Handler
TIM1_COMPB: 
reti ; Timer1 CompareB Handler
TIM1_OVF: 
reti ; Timer1 Overflow Handler
TIM0_OVF: 
reti ; Timer0 Overflow Handler
SPI_STC: 
reti ; SPI Transfer Complete Handler
USART_RXC: 
reti ; USART RX Complete Handler
USART_UDRE: 
reti ; UDR Empty Handler
USART_TXC: 
reti ; USART TX Complete Handler
ADC_COMP: 
reti ; ADC Conversion Complete Handler
EE_RDY: 
reti ; EEPROM Ready Handler
ANA_COMP: 
reti ; Analog Comparator Handler
TWSI: 
reti ; Two-wire Serial Interface Handler
EXT_INT2: 
reti ; IRQ2 Handler
TIM0_COMP: 
reti
SPM_RDY: 
reti ; Store Program Memory Ready Handler
endsnippet

snippet info
; Fecha: `date +%d/%B/%Y\ -\ %A`
; Autor: Virgilio Murillo Ochoa
; personal github: Virgilio-AI
; linkedin: https://www.linkedin.com/in/virgilio-murillo-ochoa-b29b59203
; contact: virgiliomurilloochoa1@gmail.com
endsnippet

# ==========================
# ========== basic input output ======
# ==========================
snippet inset
; input setting
; inmediate registers are bigger than 16
ldi r16, 0b00000000
out ddr${1:a-b-c-d}, r16
ldi r16, 0b11111111
out port$1, r16
endsnippet

snippet outset
; output setting
; name of register must be bigger than 16
ldi r16, 0b11111111
out ddr${1:a-b-c-d}, r16
ldi r16,0b00000000
out port$1,r16
endsnippet

snippet inp
; name of the register to load info
ldi $1, 0
in ${1:register}, pin${2:a-b-c-d}
com $1
endsnippet

snippet in
sbis pin${1:a-b-c-d}, ${2:0-7} ; check if pin is set
	jmp ${3:function} ; always return to main in this function
endsnippet


snippet out
;set clear
${1:s-c}bi port${2:a-b-c-d}, ${3:number_of_pin}
endsnippet

snippet outp
out port${1:a-b-c-d}, ${2:register}
endsnippet



# ==========================
# ========== basic operations ======
# ==========================

snippet goto
rjmp ${1:name}
; name:
endsnippet

snippet +
	subi ${1:register},-${2:number}
endsnippet

snippet -
	subi ${1:register},${2:number}
endsnippet

# ==========================
# ========== buttons ======
# ==========================

snippet retButton
retButton:
	; ============================= 
	;    delay loop generator 
	;     5000 cycles:
	; ----------------------------- 
	; delaying 4998 cycles:
			  ldi  t2, \$07
	WGLOOP0:  ldi  t1, $ED
	WGLOOP1:  dec  t1
			  brne WGLOOP1
			  dec  t2
			  brne WGLOOP0
	; ----------------------------- 
	; delaying 2 cycles:
			  nop
			  nop
	; ============================= 
ret
endsnippet

snippet retButton_h
;megahertz = 1/frecuencia del micro en ms
; ejemplo:
; 2mhz 
; #ciclos = (50 mili second - 100 mili seconds)/(1/2mhz)
endsnippet

snippet traba
traba$1:
	; after the action of the button is done
	rcall retButton
	retenido$1:
		; name of the register to load info
		sbis pin${3:a-b-c-d}, ${2:number_of_pin} ; check if pin is set
			rjmp retenido$1
	rcall retButton
	${4:ret|jmp main}
endsnippet


# ==========================
# ========== bcd display ======
# ==========================

snippet s-dis
display ${1:binary|proteus|raw} ${2:1=buttons|2=noButtons} ${3:rjmp main} ${4:pin} ${5:port}
endsnippet
snippet m-dis
menu ${1:register} ${2:return_command}
endsnippet
snippet "menu (\w+) (\w+)" "menu para display" r
`!p
def menuFunct(register,return_command):
	return_command = returnCommandSplitted(return_command)
	ans = "menu:\n"
	for a in range(0,10):
		ans+="cpi " + register + ","+ str(a)+"\n"
		ans+="\tbreq saltar_" + str(a) + "\n"
	ans += return_command
	return ans
snip.rv = menuFunct(str(match.group(1)),str(match.group(2)))
`
endsnippet
post_jump "create_matrix_placeholders(snip)"
snippet "(display) (binary|proteus|raw) (0|1) (\w+) (\w) (\w)" "configure the display" r
 `!p

def definitionOfDisplay(config,button,return_command,pin,port):
	return_command = returnCommandSplitted(return_command)
	# el arreglo de formas de hacer las cosas
	binary_values = [
	# raw values: for connecting manually
	['0b0000_0000','0b0100_1000','0b0011_1101','0b0110_1101','0b0100_1011','0b0110_0111','0b0111_0011','0b0100_1100','0b0111_1111','0b0100_1111'],
	# proteus values: the way is ment to be in documentation
	['0b0011_1111','0b0000_0110','0b0101_1011','0b0100_1111','0b0110_0110','0b0110_1101','0b0111_1101','0b0000_0111','0b0111_1111','0b0110_1111'],
	# binary values: the simplest way
	['0','1','2','3','4','5','6','7','8','9']
	]
	configInt = 0
	if config == "raw":
		configInt = 0
	elif config == "proteus":
		configInt = 1
	else:
		configInt = 2
	place1 = 1
	place2 = 2
	place3 = 3
	# primero para saltar
	ans = "" + str(t[1]) +  \
	"; ========================\n" \
	"; ======== definition of display ===\n" \
	"; ===============================\n"

	for i in range(0,10):
		ans +="saltar_" + str(i)+":\n"
		ans += "\trjmp sacar_" + str(i) + "\n"

	for i in range(0,10):
		ans += "sacar_" + str(i) + ":"  + "\n"
		ans += "\tldi t1," + binary_values[configInt][i] +"\n"
		ans += "\tout port"+port+"," + "t1" +"\n"
		if button == "1":
			ans += "\ttraba" + str(i)  + ":" + "\n"
			ans += "\t\t; name of the register to load info" + "\n"
			ans += "\t\trcall retButton" + "\n"
			ans += "\t\tretenido" + str(i) + ":" + "\n"
			ans += "\t\t\t; name of the register to load info" + "\n"
			ans += "\t\t\tsbis pin"+pin+",0 ; check if the pin is set" + "\n"
			ans += "\t\t\t\trjmp retenido" + str(i) + "\n"
			ans += "\t\t\trcall retButton"  + "\n"
		ans += "\n" +return_command + "\n"

	return ans
snip.rv = definitionOfDisplay(str(match.group(2)),str(match.group(3)),str(match.group(4)),str(match.group(5)),str(match.group(6)))
`
endsnippet


# ==========================
# ========== comparisons ======
# ==========================

snippet if
cpi ${1:register}, ${2:binary_Number}
	breq $3
endsnippet
# ==========================
# ========== asingninng ======
# ==========================

snippet var
.def ${1:register_name} = ${2:register_number}
ldi $1, ${3:0b00000000|#|0x#}
endsnippet

snippet =
; set value to cero before doing anything
; mov reg_target, second_reg
; ldi reg_target, numerical value
endsnippet

snippet def
.equ ${1:nombre}_ddr = ddr${2:a-b-c-d}
.equ $1_port = port$2
.equ $1_pin = pin$2
endsnippet

# ==========================
# ========== keyboard ======
# ==========================

snippet teclado_menu
	ldi sendSignal, 0b11111111
	out PORT_TECLADO, sendSignal

	cbi PORT_TECLADO, 0
	nop
	nop

	sbis PIN_TECLADO, 4
		rjmp TECLADO_1
	sbis PIN_TECLADO, 5
		rjmp TECLADO_2
	sbis PIN_TECLADO, 6
		rjmp TECLADO_3

	sbi PORT_TECLADO, 0
	cbi PORT_TECLADO, 1
	nop
	nop

	sbis PIN_TECLADO, 4
		rjmp TECLADO_4
	sbis PIN_TECLADO, 5
		rjmp TECLADO_5
	sbis PIN_TECLADO, 6
		rjmp TECLADO_6

	sbi PORT_TECLADO, 1
	cbi PORT_TECLADO, 2
	nop
	nop

	sbis PIN_TECLADO, 4
		rjmp TECLADO_7
	sbis PIN_TECLADO, 5
		rjmp TECLADO_8
	sbis PIN_TECLADO, 6
		rjmp TECLADO_9

	sbi PORT_TECLADO, 2
	cbi PORT_TECLADO, 3
	nop
	nop

	sbis PIN_TECLADO, 5
		rjmp TECLADO_0
endsnippet

# ==========================
# ========== timers and interruptions ======
# ==========================

snippet interrupciones
; command to set interruptions
sei
; cargamos al registro GICR para abilitar las interrupciones de forma individual
; general interrupt control register
; |int1|int0|int2|-|-|-|IVSEL|IVCE|
; default 0, 1 to enable interruptions
ldi r16, 0b${1:0}${2:0}${3:0}00000
out GICR, r16

; cargamos al registro GIFR
; general interrupt flag register
; |intf1|intf0|intf2|-|-|-|-|-|
; limpiados por default, 0=interruption in use; 1=default
ldi r16, 0b11100000
out GICR, r16

; cargamos al registro MCUCR
; configuracion de int0 y int1
; |sm2|se|sm1|isc11|isc10|isc01|isc00|
; same table with int1=isc11-isc10|int0=isc01-isc00|
; 0 0 -> low level 
; 0 1 -> any logical change
; 1 0 -> failing edge
; 1 1 -> rising edge
ldi r16, 0b_0000_${4:00}${5:00}
out MCUCR, r16

; cargamos el registro MCUCSR
; para configurar int2
; |JTD|ISC2|-|JTRF|WDRF|BORF|EXTRF|PORF|
; ISC2 == 1 : flanco de subida
; ISC2 == 0 : flanco de bajada
ldi r16,0b0${6:0}000000
out MCUCSR,r16

endsnippet


snippet timers
; configure:
; ocr0
; TIFR
; TIMSK
; TCNT0
; TCCR0
endsnippet


















