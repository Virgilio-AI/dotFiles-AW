# ------------- global functions ------
# create matrix placeholders
# create matrix
# info
# --------------- gui's with tkiner ---- 
# s-gui
# gbut -- for a button
# glab -- for a label
# gtext -- for a text box with a description
# dropMenu -- for a drop menu

# ---------------   python
# == strings
# forString - for iterate string c style
# ins - insert variable into a string

# == data structures
# list - for creating a python list
# set - unordered collection of data type, no duplicate
# tuple - same to list but inmutable

# == files
# file_open - open a file and read it line by line
# file_write - write a file
# forFolder -- traverse all files in folder
# recurseFolder -- traverse all files and subdirectories in a folder


# ---------------   matplotlib
# plotcsv
# plot2dsk
# varrange
# xyaxis
# label
# title
# legend
# fill_between
# varlim
# 2dgrid
# closestPointInLineToPoint
# 3din2d
# plotPoint
# plotFunction

# ----------------    pandas
# plotcsv
# pcombinecsv
# dataDrop
# ----------------    system interaction

# shOutput
# shCommand
# notify-send
# execute sound
# newFolder-recursive

# ---------------- organization
# sec
# subsec

































# ==========================
# ========== global functions ======
# ==========================
global !p
def create_matrix_placeholders(snip):
	# Create anonymous snippet body
	anon_snippet_body = ""
	# Get start and end line number of expanded snippet
	start = snip.snippet_start[0]
	end = snip.snippet_end[0]
  # Append current line into anonymous snippet
	for i in range(start, end + 1):
		anon_snippet_body += snip.buffer[i]
		anon_snippet_body += "" if i == end else "\n"
	# Delete expanded snippet line till second to last line
	for i in range(start, end):
		del snip.buffer[start]
	# Empty last expanded snippet line while preserving the line
	snip.buffer[start] = ''
	# Expand anonymous snippet
	snip.expand_anon(anon_snippet_body)
endglobal
post_jump "snip"
global !p
def returnCommandSplitted(command):
	cmd_arr = command.split('_')
	return_command = ""
	for a in cmd_arr:
		return_command += a + " "
	return_command = return_command[0:len(return_command)-1]
	return return_command
endglobal

post_jump "snip"
global !p

def parseStatement(i,j,k,stri):
	prev = ''
	twoBehind=''
	ans = ""
	for ch in stri:

		if ( ch == 'k' or ch == 'i' or ch == 'j' )  and prev == '$' and twoBehind == '\\':
			ans = ans[:-2]
			ans+=ch

		elif ch == 'i' and prev == '$' and twoBehind != '\\':
			ans = ans[:-1]
			ans+=str(i)
		elif ch == 'j' and prev == '$' and twoBehind != '\\':
			ans = ans[:-1]
			ans+=str(j)
		elif ch == 'k' and prev == '$' and twoBehind != '\\':
			ans = ans[:-1]
			ans+=str(k)
		elif ch == 'n' and prev == '\\':
			ans = ans[:-1]
			ans+="\n"

		else :
			ans+=ch

		twoBehind = prev
		prev = ch
	return ans

endglobal

global !p
def getMatchArr():
	cont=1
	arr = []
	while 1 :
		try :
			arr.append(match.group(cont))
			cont+=1
		except :
			break
	return arr
endglobal







# ==========================
# ========== guis with tkinker ======
# ==========================
# options im-> inword
snippet dropMenu "for creating a basic drop dow mwnu"
$3TypeLabel = Label(${4:frame},text="$3:")
$3TypeLabel.pack(side=TOP)

${1:name of list} = [
${2:"alarm",
"alert",
"zoom",
"circadian-alert",
"circadian-zoom",
"circadian-alarm"}
]

${3:name} = tk.StringVar()
$3.set($1[0]) # default value

$3DropMenu = OptionMenu($4, $3, *$1)
$3DropMenu.pack()

endsnippet
snippet s-gui
# pack is for piling elements and grid is like a spread sheet
root = Tk()
${1:frame} = Frame(root)
$1.${2:pack|grid}()
$3
root.mainloop()
endsnippet

snippet gbut
# opt parameters = fg="color",bg="color",command=lambda: function(params)
${1:name_of_button} = Button(${2:frame},text="$3").pack(side=${4:BUTTON|TOP|LEFT|RIGHT})
endsnippet

snippet glab
# opt parameters = fg="color",bg="color"
${1:name_of_label} = Label(${2:frame},text="$3").pack(side=${4:BUTTON|TOP|LEFT|RIGHT})
endsnippet

snippet gtext
$1Label = Label(level_add_task,text="$1:")
$1Label.pack(side=TOP)
# start entering information
$1 = tk.StringVar()
$1TextBox = tk.Entry(level_add_task, width = 50, textvariable = $1)
$1TextBox.pack(side=TOP)
endsnippet





snippet notify-send
os.system("notify-send \"$1\"")
endsnippet

snippet sec
# =============
# ==== $1 =====
# =============
endsnippet
snippet subsec
# ======== $1
endsnippet
snippet shOutput
${1:strinName}=str(subprocess.check_output([${2:list_commands}]).decode('utf-8'))
endsnippet
snippet shCommand
os.system('$1')
endsnippet

snippet dataDrop
${1:name_of_db}.drop(
labels=["name","example"],
axis=1, # 0 -> rows 1 -> columns
inplace=False # alter the dataFrame
)
endsnippet

# ==========================
# ========== python ======
# ==========================

snippet list
${1:temp} = [$2]
endsnippet

snippet forString
for element in range(0, len(${1:string_name})):
	print($1[element])
endsnippet

snippet set
${1:temp} = {$2}
endsnippet

snippet tuple
${1:temp} = ($2)
endsnippet

snippet ins "" im
"+str($1)+"
endsnippet
# ==========================
# ========== files ======
# ==========================
snippet file_open
with open('${1:file_name}') as ${2:file_var}:
	for line in $2:
		print(line.rstrip())
endsnippet

snippet file_write
${1:name} = open("${2:file}","w")
$1.write(${2:string})
$1.close()
endsnippet
# options im-> inword
snippet forFolder "iteration of files over folder"
# iterate over files in
# that directory
for filename in os.listdir(directory):
	f = os.path.join(directory, filename)
# checking if it is a file
	if os.path.isfile(f):
		print(f)
endsnippet
# options im-> inword
snippet recurseFolder "to recurse a folder iteractively"
def recurseFolder(path):
	for filename in os.listdir(directory):
		f = os.path.join(path,filename)
	if os.path.isfile(f):
		print(f)
	else:
		recurseFolder(minusOne
endsnippet
# ==========================
# ========== pandas ======
# ==========================

snippet plotcsv
${1:nombre} = "${2:path}"
$1_dt = pd.read_csv($1)
endsnippet

snippet plot2dsk
import matplotlib.pyplot as plt
import numpy as np

# varrange - for range and step
# varlim - for limit the min and max
# legend - for creating the legend of the different functions
# fill_between - to fill in between two functions
# closestPointInLineToPoint - creates a function for a point to be the closest
# 3din2d - to plot a 3d function into a 2d plane
# plotPoint - to plot a simple point
# plotFunction - to plot a simple function

# main parameters
x_lower_bound = $1
x_upper_bound = $2

y_lower_bound = $3
y_upper_bound = $4

#plot settings
plt.grid(True)

plt.xlim(x_lower_bound,x_upper_bound)
plt.ylim(y_lower_bound,y_upper_bound)
plt.hlines(0,x_lower_bound,x_upper_bound,color='k')
plt.vlines(0,y_lower_bound,y_upper_bound,color='k')
plt.xlabel('x1')
plt.xlabel('y1')
plt.title('Clase3Actividad4')
plt.xlabel('${5:x_label}')
plt.xlabel('${6:y_label}')
plt.title('$7')

endsnippet

snippet varrange
x = np.arange(${1:lower_bound},${2:upper_bound},${3:jump})
y = np.arange($4,$5,$6)
endsnippet


snippet xyaxis
plt.xlim(${1:lower_bound},${2:upper_bound})
plt.ylim(${3:lower_bound},${4:upper_bound})
endsnippet



snippet infoj
# %% [markdown]
- Fecha: 20/October/2021 - Wednesday
- Autor: Virgilio Murillo Ochoa
- personal github: Virgilio-AI
- linkedin: https://www.linkedin.com/in/virgilio-murillo-ochoa-b29b59203
- contact: virgiliomurilloochoa1@gmail.com
endsnippet




snippet pcombinecsv
${1:name_of_files} = glob.glob("${2:PATH/TO/FILES/file*_.csv}")
${1}_dt = pd.concat)[pd.read_csv(f) for f in ${1} ])
endsnippet





snippet plotFunction
${1:x_var} = np.arange(${2:left_range},${3:right_range},${4:step})

plt.plot($1,${5:f(x)})
endsnippet

snippet plotPoint

plt.scatter(${1:x},${2:y})
endsnippet

snippet 3din2d
${1:x_var} = np.linspace(${2:x_lower_bound},${3:x_upper_bound},${4:step})
${5:y_var} = np.linspace(${6:y_lower_bound},${7:y_upper_bound},${8:step})
X_, Y_ = np.meshgrid($1, $5)
Z_ = mainFunction(X_, Y_)
plt.contour(X_,Y_,Z_,${9:number_of_curves})

endsnippet

snippet closestPointInLineToPoint
def getClosestPointToLine(p1,p2,p3):
	x1, y1 = p1
	x2, y2 = p2
	x3, y3 = p3
	dx, dy = x2-x1, y2-y1
	det = dx*dx + dy*dy
	a = (dy*(y3-y1)+dx*(x3-x1))/det
	return x1+a*dx, y1+a*dy
endsnippet

snippet 2dgrid
plt.grid(True)
endsnippet

snippet varlim
plt.xlim(${1:left_lim},${2:right_lim})
plt.ylim(${3:left_lim},${4:right_lim})
endsnippet


snippet fill_between

# here you have to identify the lower function and the bigger function
# you can use something like below
# botton = np.maximum(y1,0)

plt.fill_between(${1:function_1},${2:function_2},${3:function_3},where=${4:x_conditions} )
endsnippet

snippet title
plt.title('$1')
endsnippet

snippet legend
#pass a list and respect the order of the plots
# format (['f(x)','g(x)'])

plt.legend(['${1:function_mathematical_representation}$2'])
endsnippet


snippet label
plt.xlabel('${1:x_description}')
plt.xlabel('${2:y_description}')
endsnippet





snippet sk

# Fecha: `date +%d/%B/%Y\ -\ %A`
# Autor: Virgilio Murillo Ochoa
# personal github: Virgilio-AI
# linkedin: https://www.linkedin.com/in/virgilio-murillo-ochoa-b29b59203
# contact: virgiliomurilloochoa1@gmail.com
from typing import *

endsnippet

snippet info
# Fecha: `date +%d/%B/%Y\ -\ %A`
# Autor: Virgilio Murillo Ochoa
# personal github: Virgilio-AI
# linkedin: https://www.linkedin.com/in/virgilio-murillo-ochoa-b29b59203
# contact: virgiliomurilloochoa1@gmail.com
endsnippet
